# -*- coding: utf-8 -*-
"""SF Permits - Project 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17JR1my3K9-Y9nqg682itmNn9yOI-n0zI

Research Question: How can building permit trends help us forecast future urban growth in specific neighborhoods?

Members: Shuteng O, Max V, Jessica G, Schadrack K

# Loading in Data
"""

import pandas as pd
import matplotlib.pyplot as plt
from scipy.stats import nbinom, linregress, probplot, lognorm
import scipy.stats as stats
import numpy as np

from google.colab import drive
drive.mount('/content/drive')

df = pd.read_csv("/content/drive")

df.head()

"""# Data Inspection"""

df.shape

# how many unknown data cells by columns
df.isna().sum()

# list the column names
df.columns

# inspecting data types
df.dtypes

"""# Data Cleaning

## Remove Duplicates, Remove Unnecessary Columns, Clean Names, Fix Timeline, Combine Addresses

Remove duplicated rows that have the same ID Number
"""

df = df.drop_duplicates(subset=['Permit Number'], keep='first').reset_index(drop=True)

"""Remove irrelevant columns data + columns with NAs (permit number, unit, site permit, TIDF compliance, street number suffix, unit suffix, block, lot, structural notification, record id)"""

df.drop(['Permit Number', 'Site Permit', 'TIDF Compliance',
        'Street Number Suffix', 'Unit Suffix', 'Unit', 'Block', 'Lot',
         'Structural Notification', 'Record ID'], axis = 1, inplace =True)

# check work
df.head()

"""Rename columns to remove whitespace and replace space with underscores"""

# replace spaces with underscores

df.columns = df.columns.str.replace(' ', '_')

# make the column names lowercase
# str.lower converts string to lowercase
# map makes sure to apply the function to each item

df.columns = map(str.lower, df.columns)

#just in case: remove trailing and leading whitespace
df.columns = df.columns.str.strip()

#sanity check
df.columns

"""Trim the timeline to account for only full years worth of data: Jan 1, 2013 - Dec 31, 2017"""

# Convert permit_creation_date to datetime
df['permit_creation_date'] = pd.to_datetime(df['permit_creation_date'], errors='coerce')

# Start and end dates
start_date = pd.to_datetime('01/01/2013')
end_date = pd.to_datetime('12/31/2017')

# Include only rows within designated time range
df = df[(df['permit_creation_date'] >= start_date) & (df['permit_creation_date'] <= end_date)]

# Display the first few rows
df.head()

"""Check if dates are right"""

df['permit_creation_date'].max()

df['permit_creation_date'].min()

df.head()

len(df)

"""Combine columns to make up an address"""

df['address'] = df['street_number'].astype(str) + ' ' + df['street_name'].astype(str) + ' ' + df['street_suffix'].astype(str)

df.head()

"""## Group existing and proposed classes"""

# look at existing use columns
df['existing_use'].unique()

df['proposed_use'].unique()

#existing use means what is the existing use of the building where the permit

#total rows in the existing_use column
total_rows = len(df['existing_use'])

#get the counts of each category in column
existing_counts = df["existing_use"].value_counts()

#calculate percentages
for category, count in existing_counts.items():
  exist_percent = (count / total_rows) * 100
  print(f'{category}: {count} permits ({exist_percent:.2f})')

#proposed use means what is the proposed use of the building where the permit

#total rows in the existing_use column
total_rows = len(df['proposed_use'])

#get the counts of each category in column
proposed_counts = df["proposed_use"].value_counts()

#calculate percentages
for category, count in proposed_counts.items():
  proposed_percent = (count / total_rows) * 100
  print(f'{category}: {count} permits ({proposed_percent:.2f})')

# define categories
categories = {
    "Residential": [
        '1 family dwelling', '2 family dwelling', 'apartments', 'residential hotel',
        'nursing home gt 6', 'nursing home lte 6', 'convalescent home', 'child care', 'orphanage',
        'misc group residns.', 'artist live/work', 'accessory cottage', 'nursing home non amb',
        'r-3(dwg) nursing'],

    "Commercial": [
        'office', 'retail sales', 'food/beverage hndlng', 'warehouse,no frnitur',
        'warehouse, furniture', 'automobile sales', 'auto repairs', 'barber/beauty salon',
        'laundry/laundromat', 'dry cleaners', 'printing plant', 'wholesale sales', 'garment shops',
        'storage tanks', 'meat/produce marts', 'lending institution', 'mortuary', 'animal sale or care',
        'moving & storage', 'car wash', 'building materials'],

    "Public/Community Services": [
        'school', 'clinics-medic/dental', 'hospital', 'church', 'temple',
        'library', 'social care facility', 'sfpd or sffd station', 'public assmbly other',
        'day care home 7 - 12', 'day care center', 'jail', 'phone xchnge/equip',
        'radio & tv stations'],

    "Entertainment/Recreation": [
        'theater', 'tourist hotel/motel', 'nite club', 'health studios & gym',
        'recreation bldg', 'dance hall', 'amusement center', 'stadium',
        'museum', 'club', 'sound studio', 'swimming pool', 'bath house'],

    "Industrial": [
        'manufacturing', 'chemical processing', 'dairies/dairy equip.',
        'workshop commercial', 'workshop residential', 'power plant',
        'storage shed', 'fence/retaining wall', 'sewage plant', 'greenhouse'],

    "Transportation/Infrastructure": [
        'prkng garage/public', 'prkng garage/private', 'filling/service stn',
        'parking lot', 'muni carbarn', 'muni driver restroom', 'ambulance service'],
    "Specialty/Other": [
        'adult entertainment', 'massage parlor', 'christmas tree lot',
        'day care home gt 12', 'day care home lt 7', 'day care, non-res',
        'antenna', 'tower', 'personal svc tutor', 'paint store',
        'roofing materials', 'vacant lot', 'sign', 'nursery(floral)',
        "prson'l svc tutor", 'nan']
}

# group use with categories defined above
def categorize_use(use):
    for category, types in categories.items():
        if use in types:
            return category
    return "Uncategorized"

# apply categorization function to both existing and proposed use
df['existing_use_category'] = df['existing_use'].apply(categorize_use)
df['proposed_use_category'] = df['proposed_use'].apply(categorize_use)

# check
print(df[['proposed_use', 'proposed_use_category']].head())
print(df[['existing_use', 'existing_use_category']].head())

df.columns

df.shape

"""## Group Neighborhoods

Check the unique neighborhoods
"""

df['neighborhoods_-_analysis_boundaries'].unique()

# define lists of neighborhoods
lower_class_neighborhoods = ['Chinatown', 'Tenderloin', 'Treasure Island', 'Bayview Hunters Point']
upper_class_neighborhoods = ['Financial District/South Beach', 'Presidio', 'Potrero Hill', 'Noe Valley']

# function to create new column and sort the neighborhoods
def classify_neighborhood(neighborhood):
    if neighborhood in lower_class_neighborhoods:
        return 'Lower Income'
    elif neighborhood in upper_class_neighborhoods:
        return 'Upper Income'
    else:
        return 'Other'

df['socioeconomic_class'] = df['neighborhoods_-_analysis_boundaries'].apply(classify_neighborhood)

df.head()

df.columns

"""## Group Permits"""

df['permit_type']=pd.to_numeric(df['permit_type'], errors='coerce')
def classify_permit_type(permit_type):
    if permit_type in [1, 2]:
        return 'Building Construction'
    elif permit_type in [4, 7]:
        return 'Signs'
    elif permit_type in [3, 5]:
        return 'Reparations'
    elif permit_type == 6:
        return 'Demolition'
    elif permit_type == 8:
        return 'Small Projects'
    else:
        return 'Other'

df['permit_category'] = df['permit_type'].apply(classify_permit_type)

df.head()

"""# Data Exploration

What are the top 5 neighborhoods with the most permits?
"""

count_of_neighborhoods = df["neighborhoods_-_analysis_boundaries"].value_counts()
percent_of_neighborhoods = (count_of_neighborhoods / count_of_neighborhoods.sum()) * 100
percent_of_neighborhoods.head()

"""What are the average estimated costs for each neighborhood?"""

estimated_costs = df.groupby("neighborhoods_-_analysis_boundaries")["estimated_cost"].mean().round(2)
estimated_costs

"""What are the average revised costs for each neighborhood?"""

revised_costs = df.groupby("neighborhoods_-_analysis_boundaries")["revised_cost"].mean().round(2)
revised_costs

"""What is the difference in estimated and revised cost?"""

(estimated_costs - revised_costs)

"""What are the average costs of each permit category within each neighborhood?"""

df.groupby(['neighborhoods_-_analysis_boundaries', 'permit_category'])['revised_cost'].mean()

"""What are the percentages each permit category in the upper & lower class areas?"""

upper_class_data = df[df['socioeconomic_class'] == 'Upper Income']
lower_class_data = df[df['socioeconomic_class'] == 'Lower Income']

upper_class_data['permit_category'].value_counts()/len(upper_class_data)*100

lower_class_data['permit_category'].value_counts()/len(lower_class_data)*100

"""What about the cost?"""

upper_class_data.groupby('permit_category')['revised_cost'].sum()/upper_class_data['revised_cost'].sum() * 100

lower_class_data.groupby('permit_category')['revised_cost'].sum()/lower_class_data['revised_cost'].sum() * 100

"""# Graphing

## Overall graphs

How has the number of permits changed over time?
"""

# aggregate data by month
df['year_month'] = df['permit_creation_date'].dt.to_period('M')  # Group by year and month
permits_by_month = df.groupby('year_month').size()

# convert to a datetime index for plotting
permits_by_month.index = permits_by_month.index.to_timestamp()

# extract the x-values (timestamps) and y-values (permit counts)
x = permits_by_month.index.astype(int) / 10**9  # convert datetime to Unix timestamp for regression
y = permits_by_month.values

# Perform linear regression
slope, intercept, r_value, p_value, std_err = linregress(x, y)
trendline = slope * x + intercept # trendline

# graph trendline and number of permits
plt.figure(figsize=(12, 6))
plt.plot(permits_by_month.index, permits_by_month.values, marker='o', linestyle='-', color='b', label="Observed Data")
plt.plot(permits_by_month.index, trendline, linestyle='--', color='r', label="Trendline")
plt.title("Number of Permits Created Over Time", fontsize=16)
plt.xlabel("Time (Year-Month)", fontsize=12)
plt.ylabel("Number of Permits", fontsize=12)
plt.grid(True, linestyle='--', alpha=0.6)
plt.xticks(rotation=45)
plt.legend()
plt.tight_layout()
plt.show()

"""How do the number of permits vary by months?"""

# extract the month from the 'permit_creation_date'
df['month'] = df['permit_creation_date'].dt.month

# group by month and count number of permits
permits_by_month = df['month'].value_counts().sort_index()

# graph it
plt.figure(figsize=(10, 6))
plt.bar(permits_by_month.index, permits_by_month.values, color='lightblue')
plt.title("Number of Permits by Month", fontsize=14)
plt.xlabel("Month", fontsize=12)
plt.ylabel("Number of Permits", fontsize=12)
plt.xticks(ticks=range(1, 13), labels=["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], rotation=45)
plt.tight_layout()
plt.show()

"""## Graphing: existing_use column"""

# group by 'existing_use_category' and count permits
top_categories_existing = df['existing_use_category'].value_counts()

# print values to double check
print(top_categories_existing)

# graph it
plt.figure(figsize=(8,6))
top_categories_existing.plot(kind='bar')
plt.title('Existing Use Categories Receiving Permits')
plt.xlabel('Category')
plt.ylabel('Number of Permits')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

df.shape

df.head()

"""## Graphing: proposed_use column"""

# group by 'proposed_use_category' and count number of permits
top_categories_proposed= df['proposed_use_category'].value_counts()

# print values to double check
print(top_categories_proposed)

# graph it
plt.figure(figsize=(8,6))
top_categories_proposed.plot(kind='bar')
plt.title('Proposed Use Categories Receiving Permits')
plt.xlabel('Category')
plt.ylabel('Number of Permits')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""## Graphing the socioeconomic classes by categories"""

# loop through each socioeconomic class and create a separate graph
for soc_class in df['socioeconomic_class'].unique():
    # filter data for the current socioeconomic class
    class_data = df[df['socioeconomic_class'] == soc_class]

    # group by use_category and count the occurrences
    class_counts = class_data['existing_use_category'].value_counts()

    # graph
    plt.figure(figsize=(10, 6))
    class_counts.plot(kind='bar', color='blue')
    plt.title(f'Distribution of Use Categories in {soc_class} Areas', fontsize=16)
    plt.xlabel('Use Category', fontsize=14)
    plt.ylabel('Count', fontsize=14)
    plt.xticks(rotation=45, fontsize=12)
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.tight_layout()
    plt.show()

df['socioeconomic_class'].unique()

# group by the 'socioeconomic_class' column, excluding "Other", and count number of permits
permits_by_class = df[df['socioeconomic_class'] != 'Other']['socioeconomic_class'].value_counts()

# assign colors
colors = ['green' if cls == 'Upper Income' else 'red' for cls in permits_by_class.index]

# graph it
plt.figure(figsize=(8, 5))
plt.bar(permits_by_class.index, permits_by_class.values, color=colors)
plt.title("Number of Permits by Socioeconomic Class", fontsize=14)
plt.xlabel("Class", fontsize=12)
plt.ylabel("Number of Permits", fontsize=12)
plt.tight_layout()
plt.show()

"""How do the numbers of residential & commerical building permits vary in each neighborhood in the upper and lower class?"""

# plot Commercial vs Residential construction by neighborhood
def plot_construction_types(df, income_class, title, color1, color2):
    # filter for the given income class and permit type
    income_df = df[df["socioeconomic_class"] == income_class]

    # count construction types per neighborhood using 'proposed_use_category'
    construction_counts = income_df.groupby(
        ["neighborhoods_-_analysis_boundaries", "proposed_use_category"]
    ).size().unstack(fill_value=0)  # fill missing values with 0

    # filter for Residential and Commercial
    construction_counts = construction_counts.reindex(columns=["Commercial", "Residential"], fill_value=0)

    # graph it
    construction_counts.plot(kind='bar', figsize=(10, 6), color=[color1, color2])
    plt.title(title, fontsize=17)
    plt.xlabel("Neighborhoods", fontsize=14)
    plt.ylabel("Number of Permits", fontsize=14)
    plt.xticks(rotation=45, fontsize=13)
    plt.legend(title="Construction Type", fontsize=13)
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.show()

# upper income construction
plot_construction_types(df, "Upper Income", "Commercial vs Residential in Upper Class Neighborhoods", "green", "lightgreen")

# lower income construction
plot_construction_types(df, "Lower Income", "Commercial vs Residential in Lower Class Neighborhoods", "maroon", "crimson")

"""# Analyzing & Graphing Costs: Revised & Estimated"""

# extract year from permit_creation_date
df['year'] = df['permit_creation_date'].dt.year

# group by year & calculate the sum of costs
yearly_costs = df.groupby('year')[['estimated_cost', 'revised_cost']].sum().reset_index()


# plot estimated and revised costs over time
plt.figure(figsize=(10, 6))  # Optional: Set figure size for better readability
plt.plot(yearly_costs['year'], yearly_costs['estimated_cost'], label='Estimated Cost', marker='o', linestyle='-', color = 'blue')
plt.plot(yearly_costs['year'], yearly_costs['revised_cost'], label='Revised Cost', marker='o', linestyle='--', color = 'blue')

# graph it
plt.xlabel('Year', fontsize=14)
plt.ylabel('Total Cost', fontsize=14)
plt.title('Overall Estimated vs Revised Costs Over Time', fontsize=16)
plt.legend(fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.xticks(yearly_costs['year'], rotation=45)
plt.tight_layout()
plt.show()

high_income = df[df['socioeconomic_class'] == 'Upper Income']
low_income = df[df['socioeconomic_class'] == 'Lower Income']

# group by year and calculate the sum of costs for each class
high_income_yearly_costs = high_income.groupby('year')[['estimated_cost', 'revised_cost']].sum().reset_index()
low_income_yearly_costs = low_income.groupby('year')[['estimated_cost', 'revised_cost']].sum().reset_index()

# plot estimated and revised costs for high-income neighborhoods
plt.figure(figsize=(12, 6))
plt.plot(
    high_income_yearly_costs['year'],
    high_income_yearly_costs['estimated_cost'],
    label='Estimated Cost (Upper Income)',
    marker='x',
    linestyle='--',
    color = 'green'
)
plt.plot(
    high_income_yearly_costs['year'],
    high_income_yearly_costs['revised_cost'],
    label='Revised Cost (Upper Income)',
    marker='o',
    linestyle='-',
    color = 'green'
)

# plot estimated and revised costs for low-income neighborhoods
plt.plot(
    low_income_yearly_costs['year'],
    low_income_yearly_costs['estimated_cost'],
    label='Estimated Cost (Lower Income)',
    marker='x',
    linestyle='--',
    color = 'red'
)
plt.plot(
    low_income_yearly_costs['year'],
    low_income_yearly_costs['revised_cost'],
    label='Revised Cost (Lower Income)',
    marker='o',
    linestyle='-',
    color = 'red'
)

# graph it
plt.xlabel('Year', fontsize=14)
plt.ylabel('Total Cost (in Billions)', fontsize=14)
plt.title('Estimated vs Revised Costs by Socioeconomic Class Over Time', fontsize=16)
plt.legend(fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.xticks(high_income_yearly_costs['year'], rotation=45)

plt.tight_layout()
plt.show()

"""## Estimated vs. Revised Costs by Permit Category (Socioeconomic Class)"""

# group by year and permit category to sum estimated and revised costs
upper_income_costs = high_income.groupby(['year', 'permit_category'])[['estimated_cost', 'revised_cost']].sum().unstack(fill_value=0)
lower_income_costs = low_income.groupby(['year', 'permit_category'])[['estimated_cost', 'revised_cost']].sum().unstack(fill_value=0)

# get all unique permit categories
all_permit_categories = upper_income_costs.columns.get_level_values(1).unique()

# plot each permit category separately
for category in all_permit_categories:
    plt.figure(figsize=(10, 5))

    # graph estimated cost for upper
    plt.plot(
        upper_income_costs.index,
        upper_income_costs[('estimated_cost', category)],
        label=f'Estimated Cost (Upper Income) - {category}',
        marker='x',
        linestyle='--',
        color='green'
    )

    # graph revised cost for upper
    plt.plot(
        upper_income_costs.index,
        upper_income_costs[('revised_cost', category)],
        label=f'Revised Cost (Upper Income) - {category}',
        marker='o',
        linestyle='-',
        color='green'
    )

    # graph estimated cost for lower
    plt.plot(
        lower_income_costs.index,
        lower_income_costs[('estimated_cost', category)],
        label=f'Estimated Cost (Lower Income) - {category}',
        marker='x',
        linestyle='--',
        color='red'
    )

    # graph revised cost for lower
    plt.plot(
        lower_income_costs.index,
        lower_income_costs[('revised_cost', category)],
        label=f'Revised Cost (Lower Income) - {category}',
        marker='o',
        linestyle='-',
        color='red'
    )

    plt.xlabel('Year', fontsize=12)
    plt.ylabel('Total Cost (in Billions $)', fontsize=12)
    plt.title(f'Estimated vs. Revised Cost for {category} Over Time', fontsize=14)
    plt.legend(fontsize=10)
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.xticks(rotation=45)

    plt.tight_layout()
    plt.show()

"""## Average estimated and revised cost in each upper and lower class neighborhoods"""

# calculate the average estimated and revised cost for each upper neighborhood
high_avg_costs = high_income.groupby("neighborhoods_-_analysis_boundaries")[
    ["estimated_cost", "revised_cost"]
].mean()

# graph it
plt.figure(figsize=(10, 6))
high_avg_costs.plot(kind='bar', figsize=(10,6))
plt.title("Average Estimated and Revised Construction Costs in Upper Income Neighborhoods")
plt.xlabel("Neighborhoods")
plt.ylabel("Cost ($)")
plt.xticks(rotation=45)
plt.legend(["Estimated Cost", "Revised Cost"])
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# calculate the average estimated and revised cost for each low neighborhood
low_avg_costs = low_income.groupby("neighborhoods_-_analysis_boundaries")[
    ["estimated_cost", "revised_cost"]
].mean()

# graph it
plt.figure(figsize=(10, 6))
low_avg_costs.plot(kind='bar', figsize=(10,6))
plt.title("Average Estimated and Revised Construction Costs in Lower Income Neighborhoods")
plt.xlabel("Neighborhoods")
plt.ylabel("Cost ($)")
plt.xticks(rotation=45)
plt.legend(["Estimated Cost", "Revised Cost"])
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

"""## Estimated and Revised Cost of Construction"""

# function to calculate and plot construction costs by income class
def plot_construction_costs(df, income_class, title, color1, color2):
    # filter for the given income class & building construction permit category
    income_df = df[(df["socioeconomic_class"] == income_class) & (df["permit_category"] == "Building Construction")]

    # calculate the average estimated and revised cost for each neighborhood
    avg_costs = income_df.groupby("neighborhoods_-_analysis_boundaries")[
        ["estimated_cost", "revised_cost"]
    ].mean()

    # graph it
    plt.figure(figsize=(10, 6))
    avg_costs.plot(kind='bar', figsize=(10,6),color=[color1, color2])
    plt.title(title, fontsize=17)
    plt.xlabel("Neighborhoods",fontsize=14)
    plt.ylabel("Cost (in hundred millions $)",fontsize=14)
    plt.xticks(rotation=45, fontsize=14)
    plt.legend(["Estimated Cost", "Revised Cost"],fontsize=13)
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.show()

# upper neighborhood
plot_construction_costs(df, "Upper Income", "Average Construction Costs in Upper Class Neighborhoods", "orange", "maroon")

# lower neighborhood
plot_construction_costs(df, "Lower Income", "Average Construction Costs in Lower Class Neighborhoods", "orange", "maroon")

"""# Analyzing & Graphing Permit Category Overtime by Socioeconomic Class"""

# group by year and permit category to count occurrences
upper_income_counts = high_income.groupby(['year', 'permit_category']).size().unstack(fill_value=0)
lower_income_counts = low_income.groupby(['year', 'permit_category']).size().unstack(fill_value=0)

# top 5 permit categories overall (sum of both income groups)
top_5_permit_categories = (upper_income_counts.sum() + lower_income_counts.sum()).nlargest(5).index

# graph each of the top 5 permit categories separately
plt.figure(figsize=(12, 6))
for category in top_5_permit_categories:
    plt.figure(figsize=(10, 5))

    # graph for upper
    plt.plot(
        upper_income_counts.index,
        upper_income_counts[category],
        label=f'Upper Class - {category}',
        marker='o',
        linestyle='-',
        color = 'green'
    )

    # graph for lower
    plt.plot(
        lower_income_counts.index,
        lower_income_counts[category],
        label=f'Lower Class - {category}',
        marker='o',
        linestyle='-',
        color = 'red'
    )

    plt.xlabel('Year', fontsize=12)
    plt.ylabel('Number of Permits', fontsize=12)
    plt.title(f'Permit Category: {category} Over Time', fontsize=14)
    plt.legend(fontsize=10)
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.xticks(rotation=45)

    plt.figure(figsize=(10, 5))
    plt.tight_layout()
    plt.show()

# plot commercial vs residential construction by neighborhood
def plot_construction_types(df, income_class, permit_type, title, color1, color2):
    # Filter for the given income class and permit type
    income_df = df[(df["socioeconomic_class"] == income_class) & (df["permit_category"] == permit_type)]

    # count construction types per neighborhood using 'proposed_use_category'
    construction_counts = income_df.groupby(
        ["neighborhoods_-_analysis_boundaries", "proposed_use_category"]
    ).size().unstack(fill_value=0)  # Fill missing values with 0

    # filter for residential and commercial)
    construction_counts = construction_counts.reindex(columns=["Commercial", "Residential"], fill_value=0)

    # graph it
    construction_counts.plot(kind='bar', figsize=(10, 6), color=[color1, color2])
    plt.title(title, fontsize=17)
    plt.xlabel("Neighborhoods", fontsize=14)
    plt.ylabel("Number of Construction Permits", fontsize=14)
    plt.xticks(rotation=45, fontsize=13)
    plt.legend(title="Construction Type", fontsize=13)
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.show()

# upper income construction
plot_construction_types(df, "Upper Income", "Building Construction", "Commercial vs Residential Construction in Upper Class Neighborhoods", "green", "lightgreen")

# lower income construction
plot_construction_types(df, "Lower Income", "Building Construction", "Commercial vs Residential Construction in Lower Class Neighborhoods", "maroon", "crimson")

"""What is the average cost of construction in each neighborhood?"""

# filter for building construction permits
building_construction_df = df[df["permit_category"] == "Building Construction"]

# calculate the average revised cost by neighborhood and use category for upper and lower neighborhoods
avg_cost = (
    building_construction_df.groupby(["socioeconomic_class", "neighborhoods_-_analysis_boundaries", "proposed_use_category"])["revised_cost"]
    .mean()
    .unstack(fill_value=0)  # missing categories are filled with 0
)

avg_cost

"""# Probability Distribution Modeling Graphs

What is the number of permits predicted a day?
"""

permits_by_day = df.groupby(df['permit_creation_date'].dt.date).size()

# calculate mean and variance
mean_count_all = permits_by_day.mean()
variance_count_all = permits_by_day.var()

print(f"Mean (λ): {mean_count_all}")
print(f"Variance: {variance_count_all}")

# method of moments estimation
p = mean_count_all / variance_count_all # p - probability of success
r = mean_count_all ** 2 / (variance_count_all - mean_count_all) # r - number of successess

print(f"Estimated parameters: r = {r}, p = {p}")

# generate nbinom probabilities
x = np.arange(0, max(permits_by_day) + 1) # trials for the rth success
pmf = nbinom.pmf(x, r, p) # probability mass function

# histogram and fitted distribution (to check)
plt.figure(figsize=(10, 6))
plt.hist(permits_by_day, bins=30, density=True, alpha=0.6, color='g', label="Observed Data")
plt.plot(x, pmf, 'r-', lw=2, label="Negative Binomial Fit")
plt.title("Negative Binomial Distribution Fit for Building Permits Created in San Francisco")
plt.xlabel("Permit Count")
plt.ylabel("Probability")
plt.legend()
plt.show()

"""Repeat for upper class"""

# calculate daily counts in upper class
daily_counts_up = high_income.groupby(high_income['permit_creation_date'].dt.date).size()

# mean and variance
mean_count_up = daily_counts_up.mean()
variance_count_up = daily_counts_up.var()

print(f"Mean (λ): {mean_count_up}")
print(f"Variance: {variance_count_up}")

# method of moments estimation
p = mean_count_up / variance_count_up # p - probability of success
r = mean_count_up ** 2 / (variance_count_up - mean_count_up) # r - number of successes

print(f"Estimated parameters: r = {r}, p = {p}")

x = np.arange(0, max(daily_counts_up) + 1) # trials for the rth success
pmf = nbinom.pmf(x, r, p) # probability mass function

# histogram and fitted distribution (to check)
plt.figure(figsize=(10, 6))
plt.hist(daily_counts_up, bins=30, density=True, alpha=0.6, color='g', label="Observed Data")
plt.plot(x, pmf, 'r-', lw=2, label="Negative Binomial Fit")
plt.title("Negative Binomial Distribution Fit for Building Permits Created in Upper Class Neighborhoods")
plt.xlabel("Permit Count")
plt.ylabel("Probability")
plt.legend()
plt.show()

"""Repeat for lower class"""

# calculate daily counts in lower class
daily_counts_low = low_income.groupby(low_income['permit_creation_date'].dt.date).size()

# mean and variance
mean_count_low  = daily_counts_low .mean()
variance_count_low  = daily_counts_low .var()

print(f"Mean (λ): {mean_count_low }")
print(f"Variance: {variance_count_low }")

# method of moments estimation
p = mean_count_low  / variance_count_low # p - probability of success
r = mean_count_low  ** 2 / (variance_count_low  - mean_count_low ) # r - number of successes

print(f"Estimated parameters: r = {r}, p = {p}")

x = np.arange(0, max(daily_counts_low) + 1) # trials for the rth success
pmf = nbinom.pmf(x, r, p) # probability mass function

# histogram and fitted distribution (to check)
plt.figure(figsize=(10, 6))
plt.hist(daily_counts_low, bins=30, density=True, alpha=0.6, color='g', label="Observed Data")
plt.plot(x, pmf, 'r-', lw=2, label="Negative Binomial Fit")
plt.title("Negative Binomial Distribution Fit for Building Permits Created in Lower Class Neighborhoods")
plt.xlabel("Permit Count")
plt.ylabel("Probability")
plt.legend()
plt.show()